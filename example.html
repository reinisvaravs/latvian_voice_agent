<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LV Voice Agent MVP</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
      }
      button {
        padding: 10px 20px;
        margin: 5px;
        cursor: pointer;
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      #log {
        background: #f5f5f5;
        padding: 15px;
        border-radius: 5px;
        font-family: monospace;
        white-space: pre-wrap;
        max-height: 400px;
        overflow-y: auto;
        margin-top: 20px;
      }
      .notes {
        background: #e8f4fd;
        padding: 15px;
        border-radius: 5px;
        margin: 20px 0;
      }
      .input-level {
        background: #f0f0f0;
        border: 1px solid #ccc;
        padding: 8px 12px;
        border-radius: 4px;
        font-family: monospace;
        font-size: 14px;
        margin: 8px 0;
        display: inline-block;
      }
    </style>
  </head>
  <body>
    <h1>LV Voice Agent MVP</h1>

    <div style="margin: 12px 0">
      <button id="start">Start Agent</button>
      <button id="stop" disabled>Stop</button>
    </div>

    <audio id="agentAudio" autoplay></audio>

    <div id="log"></div>

    <script>
      // DOM Elements
      const logEl = document.getElementById("log");
      const startBtn = document.getElementById("start");
      const stopBtn = document.getElementById("stop");
      const agentAudio = document.getElementById("agentAudio");

      // Global Variables
      let pc, micStream, dc;

      // AI Configuration - Simplified
      const AI_CONFIG = {
        welcomeMessage:
          "Sveiki! Es esmu jūsu balss palīgs. Kā es varu jums palīdzēt?",
        welcomeDelay: 1000,
        autoGreet: true,
        userSetupMessage:
          "Es gribu sarunāties latviešu valodā. Lūdzu atbildi tikai latviešu valodā.",
        setupDelay: 500,
        speechSpeed: 1.0,
        voice: "echo",
      };

      // Utility Functions
      function log(msg) {
        console.log(msg);
        const now = new Date();
        const time = now.toLocaleTimeString();
        const formattedMsg = `[${time}] ${msg}`;
        logEl.textContent += formattedMsg + "\n";
        logEl.scrollTop = logEl.scrollHeight;
      }

      function buildInstructions() {
        return `
Tu esi klientu kvalifikācijas aģents. Runā TIKAI latviešu valodā.

Tavas funkcijas:
- Sveicini klientus draudzīgi
- Uzdod jautājumus par viņu vajadzībām
- Novērtē klienta piemērotību
- Paskaidro nākamos soļus

SVARĪGI: Atbildi TIKAI latviešu valodā!
        `;
      }

      function pushSessionUpdate() {
        if (!dc || dc.readyState !== "open") return;

        const instructions = buildInstructions();
        const payload = {
          type: "session.update",
          session: {
            turn_detection: {
              type: "server_vad",
              threshold: 0.5, // Default OpenAI threshold
              prefix_padding_ms: 2000, // Default OpenAI padding
              silence_duration_ms: 1000, // Default OpenAI silence duration
              create_response: true,
              interrupt_response: false,
            },
            max_response_output_tokens: 500, // Much higher token limit for longer responses
            temperature: 0.6, // Hardcoded for consistent speech
            speed: AI_CONFIG.speechSpeed,
            voice: AI_CONFIG.voice,
            instructions,
          },
        };

        try {
          dc.send(JSON.stringify(payload));
          log("⚙️ Settings updated");
        } catch (e) {
          log("❌ Settings failed: " + e.message);
        }
      }

      function sendUserSetupMessage() {
        if (!dc || dc.readyState !== "open") return;

        const userMessage = {
          type: "conversation.item.create",
          item: {
            type: "message",
            role: "user",
            content: [{ type: "input_text", text: AI_CONFIG.userSetupMessage }],
          },
        };

        try {
          dc.send(JSON.stringify(userMessage));
          log("👤 User setup: " + AI_CONFIG.userSetupMessage);
        } catch (e) {
          log("❌ Failed to send user setup: " + e.message);
        }
      }

      function triggerAIResponse() {
        if (!dc || dc.readyState !== "open") return;

        const welcomeMessage = {
          type: "conversation.item.create",
          item: {
            type: "message",
            role: "user",
            content: [{ type: "input_text", text: AI_CONFIG.welcomeMessage }],
          },
        };

        try {
          dc.send(JSON.stringify(welcomeMessage));
          log("🎯 Triggering AI welcome message");
        } catch (e) {
          log("❌ Failed to trigger AI: " + e.message);
        }
      }

      // Event Handlers
      startBtn.onclick = async () => {
        try {
          micStream = await navigator.mediaDevices.getUserMedia({
            audio: {
              channelCount: 1,
            },
          });

          pc = new RTCPeerConnection();
          const track = micStream.getAudioTracks()[0];
          pc.addTrack(track, micStream);

          pc.ontrack = (e) => {
            agentAudio.srcObject = e.streams[0];
            log("🔊 Audio connected");
          };

          dc = pc.createDataChannel("events");
          dc.onopen = () => {
            log("✅ Connected");
            pushSessionUpdate();

            if (AI_CONFIG.autoGreet) {
              setTimeout(() => sendUserSetupMessage(), AI_CONFIG.setupDelay);
              setTimeout(() => triggerAIResponse(), AI_CONFIG.welcomeDelay);
            }
          };

          dc.onmessage = (evt) => {
            try {
              const data = JSON.parse(evt.data);

              // Only log important events to reduce noise
              if (
                data.type === "response.text" ||
                data.type === "response.audio" ||
                data.type === "error"
              ) {
                log(`📡 Event: ${data.type}`);
              }

              switch (data.type) {
                case "response.text":
                  if (data.response && data.response.text) {
                    log("💬 AI: " + data.response.text);
                  } else if (data.text) {
                    log("💬 AI: " + data.text);
                  }
                  break;
                case "response.audio":
                  log("🔊 AI speaking");
                  break;
                case "turn.end":
                  log("⏹️ AI finished");
                  break;
                case "response.end":
                  log("✅ Response complete");
                  break;
                case "error":
                  if (data.error && data.error.message) {
                    log("❌ Error: " + data.error.message);
                  }
                  break;
                case "session.created":
                case "session.updated":
                case "conversation.item.created":
                case "input_audio_buffer.speech_started":
                case "input_audio_buffer.speech_ended":
                  // Silent handling of common events
                  break;
                default:
                  // Only log truly unknown events
                  if (
                    !data.type.includes("input_audio_buffer") &&
                    !data.type.includes("session") &&
                    !data.type.includes("conversation")
                  ) {
                    log(`❓ Unknown event: ${data.type}`);
                  }
                  break;
              }
            } catch (e) {
              log("❌ Parse error: " + e.message);
            }
          };

          const offer = await pc.createOffer({ offerToReceiveAudio: true });
          await pc.setLocalDescription(offer);

          const resp = await fetch("/realtime/sdp", {
            method: "POST",
            headers: { "Content-Type": "application/sdp" },
            body: offer.sdp,
          });

          if (!resp.ok) {
            const txt = await resp.text();
            throw new Error("Failed to connect to AI agent: " + txt);
          }

          const answerSdp = await resp.text();
          await pc.setRemoteDescription({ type: "answer", sdp: answerSdp });

          startBtn.disabled = true;
          stopBtn.disabled = false;
          log("🎉 Ready to talk!");
        } catch (e) {
          log("❌ Failed: " + e.message);
        }
      };

      stopBtn.onclick = async () => {
        try {
          if (dc && dc.readyState === "open") dc.close();
          if (pc) pc.close();
          if (micStream) micStream.getAudioTracks().forEach((t) => t.stop());
        } finally {
          startBtn.disabled = false;
          stopBtn.disabled = true;
          log("👋 Disconnected");
        }
      };
    </script>
  </body>
</html>
